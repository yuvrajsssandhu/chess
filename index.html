<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess</title>
    <style>
        /* Shared Styles */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', sans-serif;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: url('Chess-background.png') no-repeat center center fixed;
            background-size: cover;
            color: #3e4b2b;
            text-align: center;
            overflow: hidden;
            transition: opacity 1s ease-in-out;
        }

        /* Landing Page Styles */
        #landing-page {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 60vh;
            animation: fadeIn 1.5s ease-out;
        }

        #landing-page h1 {
            font-size: 4rem;
            margin-bottom: 10px;
            color: #2e7d32;
            text-shadow: 2px 2px 6px #000;
        }

        #landing-page p {
            font-size: 1.4rem;
            margin-bottom: 50px;
            line-height: 1.3;
            color: #d2b48c;
            text-shadow: 1px 1px 4px #000;
        }

        #landing-page .buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        #landing-page .buttons a {
            padding: 15px 40px;
            background-color: #388e3c;
            color: #fff;
            text-decoration: none;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 12px;
            box-shadow: 0 5px 15px #000;
            transition: all 0.3s ease;
            width: 220px;
            text-align: center;
            cursor: pointer;
        }

        #landing-page .buttons a:hover {
            transform: scale(1.05);
            background-color: #6d4c41;
            box-shadow: 0 10px 25px #000;
        }

        #landing-page footer {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            font-size: 1rem;
            opacity: 0.9;
            color: #d2b48c;
            text-shadow: 1px 1px 3px #000;
        }

        /* Chess Game Styles (initially hidden) */
        #game-page {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            gap: 20px;
        }

        .game-container {
            display: flex;
            align-items: flex-start;
            gap: 20px;
        }

        table {
            border-collapse: collapse;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.7);
            border-radius: 10px;
        }

        td {
            width: 80px;
            height: 80px;
            text-align: center;
            vertical-align: middle;
            font-size: 60px;
            cursor: pointer;
            position: relative;
            transition: transform 0.5s ease-in-out;
        }

        .light { background: #e0cab3; }
        .dark { background: #2E8B57; }

        .moveOption::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 25px;
            height: 25px;
            border-radius: 50%;
            border: 2px solid yellow;
            background: rgba(255, 255, 0, 0.2);
        }

        .checkedKing { background: red !important; }

        #status {
            font-size: 20px;
            color: #fff;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            margin: 0;
            text-align: center;
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #right-panel {
            display: flex;
            flex-direction: column;
            height: 100%;
            justify-content: space-between;
            width: 200px;
        }

        #gameControls {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            flex: 1;
        }

        #gameControls button {
            background-color: #f0f0f0;
            color: #333;
            border: none;
            border-radius: 3px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
            width: 100%;
            box-sizing: border-box;
        }

        #gameControls button:hover {
            background-color: #e0e0e0;
        }

        .piece-black {
            color: #000;
            text-shadow: -1px -1px 0 white, 1px -1px 0 white, -1px 1px 0 white, 1px 1px 0 white;
        }

        .piece-white {
            color: #fff;
            text-shadow: -1px -1px 0 black, 1px -1px 0 black, -1px 1px 0 black, 1px 1px 0 black;
        }

        .rotated-piece {
            transform: rotate(180deg);
        }

        #promotionMenu {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            z-index: 100;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            gap: 15px;
        }

        .promotion-option {
            font-size: 50px;
            background: transparent;
            border: 2px solid #333;
            color: #000;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .promotion-option:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        #victoryScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 200;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            animation: fadeIn 1s forwards;
        }

        #victoryScreen h2 {
            font-size: 5em;
            color: gold;
            text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.7);
            transform: scale(0.5);
            animation: zoomIn 1.5s forwards;
        }

        #victoryScreen button {
            margin-top: 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.5em;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.3s;
        }

        #victoryScreen button:hover {
            background-color: #45a049;
            transform: scale(1.05);
        }
        
        /* Confirmation Menu Styles */
        #confirmationMenu {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 300;
            justify-content: center;
            align-items: center;
        }
        
        .confirmation-box {
            background-color: #f5f5dc;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            text-align: center;
            animation: fadeIn 0.5s ease-in-out;
        }
        
        .confirmation-box p {
            font-size: 1.2rem;
            margin-bottom: 20px;
            color: #333;
        }
        
        .confirmation-buttons button {
            padding: 10px 20px;
            font-size: 1rem;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            margin: 0 10px;
            transition: background-color 0.3s;
        }
        
        #confirmYes {
            background-color: #d9534f;
            color: white;
        }
        
        #confirmYes:hover {
            background-color: #c9302c;
        }
        
        #confirmNo {
            background-color: #5cb85c;
            color: white;
        }
        
        #confirmNo:hover {
            background-color: #4cae4c;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-50px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes zoomIn {
            from { transform: scale(0.5); }
            to { transform: scale(1); }
        }
    </style>
</head>
<body>
    <div id="landing-page">
        <div class="container">
            <h1>Welcome to Chess Abyss</h1>
            <p>This is a game made for you to play with HIM.</p>
            <div class="buttons">
                <a href="#" id="startGameBtn">Start 2-Player Game</a>
                <a href="#">Settings</a>
            </div>
        </div>
    </div>

    <div id="game-page">
        <div class="game-container">
            <table id="chessBoard"></table>
            <div id="right-panel">
                <div id="gameControls">
                    <button id="undoBtn">Undo</button>
                    <button id="redoBtn">Redo</button>
                    <button id="homeBtn">Home</button>
                </div>
                <div id="status"></div>
            </div>
        </div>

        <div id="promotionMenu"></div>
        <div id="victoryScreen">
            <h2 id="victoryMessage"></h2>
            <button id="newGameBtn">New Game</button>
        </div>
        
        <div id="confirmationMenu">
            <div class="confirmation-box">
                <p>Are you sure you want to go to the home page? This will reset the game.</p>
                <div class="confirmation-buttons">
                    <button id="confirmYes">Yes</button>
                    <button id="confirmNo">No</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Page Navigation
        const landingPage = document.getElementById('landing-page');
        const gamePage = document.getElementById('game-page');
        const startGameBtn = document.getElementById('startGameBtn');
        const homeBtn = document.getElementById('homeBtn');
        const confirmationMenu = document.getElementById('confirmationMenu');
        const confirmYesBtn = document.getElementById('confirmYes');
        const confirmNoBtn = document.getElementById('confirmNo');

        startGameBtn.addEventListener('click', () => {
            landingPage.style.display = 'none';
            gamePage.style.display = 'flex';
            initGame();
        });

        homeBtn.addEventListener('click', () => {
            confirmationMenu.style.display = 'flex';
        });

        confirmYesBtn.addEventListener('click', () => {
            confirmationMenu.style.display = 'none';
            gamePage.style.display = 'none';
            landingPage.style.display = 'flex';
        });

        confirmNoBtn.addEventListener('click', () => {
            confirmationMenu.style.display = 'none';
        });
        
        // Chess Game Logic
        const boardEl = document.getElementById("chessBoard");
        const statusEl = document.getElementById("status");
        const undoBtn = document.getElementById("undoBtn");
        const redoBtn = document.getElementById("redoBtn");
        const newGameBtn = document.getElementById("newGameBtn");
        const promotionMenuEl = document.getElementById("promotionMenu");
        const victoryScreenEl = document.getElementById("victoryScreen");
        const victoryMessageEl = document.getElementById("victoryMessage");
        const unicodePieces = {'r':'♜','n':'♞','b':'♝','q':'♛','k':'♚','p':'♟','R':'♖','N':'♘','B':'♗','Q':'♕','K':'♔','P':'♙'};

        // Sound effects
        const moveSound = new Audio('piece-move.mp3');
        const captureSound = new Audio('piece-taken.mp3');
        const checkSound = new Audio('check.mp3');
        const checkmateSound = new Audio('victory.mp3');

        let chessBoard, turn, selected, moveHistory, redoHistory, castlingRights, enPassantTarget;
        let promotionTarget = null;

        newGameBtn.onclick = initGame;

        function initGame(){
            chessBoard = [
                ['r','n','b','q','k','b','n','r'],
                ['p','p','p','p','p','p','p','p'],
                ['','','','','','','',''],
                ['','','','','','','',''],
                ['','','','','','','',''],
                ['','','','','','','',''],
                ['P','P','P','P','P','P','P','P'],
                ['R','N','B','Q','K','B','N','R']
            ];
            turn = 'white';
            selected = null;
            moveHistory = [];
            redoHistory = [];
            enPassantTarget = null;
            castlingRights = { w: { K: true, Q: true }, b: { k: true, q: true } };
            victoryScreenEl.style.display = 'none';
            drawBoard();
        }

        function inBounds(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
        function isWhite(p){ return p === p.toUpperCase(); }

        function drawBoard(){
            boardEl.innerHTML = '';
            for(let i=0; i<8; i++){
                const row = document.createElement('tr');
                for(let j=0; j<8; j++){
                    const cell = document.createElement('td');
                    const piece = chessBoard[i][j];
                    cell.className = (i+j)%2===0 ? 'light' : 'dark';
                    if (piece) {
                        if (isWhite(piece)) {
                            cell.classList.add('piece-white');
                        } else {
                            cell.classList.add('piece-black');
                            cell.classList.add('rotated-piece');
                        }
                    }
                    cell.textContent = unicodePieces[piece] || '';
                    cell.dataset.r = i; cell.dataset.c = j;
                    cell.onclick = () => selectCell(i,j);
                    row.appendChild(cell);
                }
                boardEl.appendChild(row);
            }
            highlightCheck();
            updateStatus();
        }

        function highlightCheck(){
            const kingPos = findKing(turn);
            if (!kingPos) return;
            boardEl.querySelectorAll('.checkedKing').forEach(c => c.classList.remove('checkedKing'));
            if(isInCheck(turn, chessBoard)){
                boardEl.rows[kingPos[0]].cells[kingPos[1]].classList.add('checkedKing');
            }
        }

        function selectCell(r,c){
            const piece = chessBoard[r][c];
            if(selected){
                const legalMoves = getLegalMoves(selected[0], selected[1]);
                if(legalMoves.some(([nr, nc]) => nr === r && nc === c)){
                    saveState();
                    const movingPiece = chessBoard[selected[0]][selected[1]];
                    
                    if(movingPiece.toUpperCase() === 'P' && (r === 0 || r === 7)){
                        promotionTarget = [r, c];
                        movePiece(selected[0], selected[1], r, c, true); 
                        showPromotionMenu();
                    } else {
                        movePiece(selected[0], selected[1], r, c);
                    }
                    selected = null;
                } else {
                    selected = null;
                    drawBoard(); 
                }
            } else if(piece && ((turn === 'white' && isWhite(piece)) || (turn === 'black' && !isWhite(piece)))){
                selected = [r, c];
                highlightMoves(r, c);
            }
        }

        function showPromotionMenu(){
            promotionMenuEl.innerHTML = '';
            const promotingPlayer = turn;
            const pieces = ['Q', 'R', 'B', 'N'];
            pieces.forEach(p => {
                const option = document.createElement('div');
                option.classList.add('promotion-option');
                if (promotingPlayer === 'white') {
                    option.classList.add('piece-white');
                    option.textContent = unicodePieces[p];
                } else {
                    option.classList.add('piece-black');
                    option.textContent = unicodePieces[p.toLowerCase()];
                }
                option.onclick = () => handlePromotion(promotingPlayer === 'white' ? p : p.toLowerCase());
                promotionMenuEl.appendChild(option);
            });
            promotionMenuEl.style.display = 'flex';
        }

        function handlePromotion(piece){
            const [r, c] = promotionTarget;
            chessBoard[r][c] = piece;
            promotionMenuEl.style.display = 'none';
            promotionTarget = null;
            turn = (turn === 'white')?'black':'white';
            drawBoard();
            checkGameOver();
        }

        function highlightMoves(r,c){
            drawBoard();
            const moves = getLegalMoves(r,c);
            moves.forEach(([mr,mc]) => { boardEl.rows[mr].cells[mc].classList.add('moveOption'); });
        }

        function getLegalMoves(r,c){
            const piece = chessBoard[r][c];
            if(!piece) return [];
            const pseudoLegalMoves = [];
            const type = piece.toUpperCase();
            const dirs = {
                'N': [[-2,-1],[-1,-2],[1,-2],[2,-1],[2,1],[1,2],[-1,2],[-2,1]],
                'B': [[-1,-1],[-1,1],[1,-1],[1,1]],
                'R': [[-1,0],[1,0],[0,-1],[0,1]],
                'Q': [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]],
                'K': [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]]
            };

            if(type === 'P'){
                const dir = isWhite(piece) ? -1 : 1;
                // Forward move
                if(inBounds(r+dir, c) && !chessBoard[r+dir][c]) {
                    pseudoLegalMoves.push([r+dir, c]);
                    // Double move from starting row
                    if(((r===6 && piece==='P') || (r===1 && piece==='p')) && !chessBoard[r+2*dir][c]){
                        pseudoLegalMoves.push([r+2*dir, c]);
                    }
                }
                // Captures
                for(const dc of [-1, 1]){
                    const targetPiece = inBounds(r+dir, c+dc) ? chessBoard[r+dir][c+dc] : '';
                    if(targetPiece && isWhite(targetPiece) !== isWhite(piece)){
                        pseudoLegalMoves.push([r+dir, c+dc]);
                    }
                }
                // En passant
                if(enPassantTarget && enPassantTarget[0] === r+dir && (enPassantTarget[1] === c+1 || enPassantTarget[1] === c-1)){
                    pseudoLegalMoves.push([r+dir, enPassantTarget[1]]);
                }
            } else {
                for(const [dr, dc] of dirs[type]){
                    let nr = r+dr, nc = c+dc;
                    while(inBounds(nr, nc)){
                        if(!chessBoard[nr][nc]){
                            pseudoLegalMoves.push([nr, nc]);
                        } else {
                            if(isWhite(chessBoard[nr][nc]) !== isWhite(piece)) pseudoLegalMoves.push([nr, nc]);
                            break;
                        }
                        if(['N','K'].includes(type)) break;
                        nr += dr; nc += dc;
                    }
                }
            }
            // Castling logic
            if (type === 'K' && !isInCheck(turn, chessBoard)) {
                const kingRow = isWhite(piece) ? 7 : 0;
                const rights = isWhite(piece) ? castlingRights.w : castlingRights.b;
                const kingSideKey = isWhite(piece) ? 'K' : 'k';
                const queenSideKey = isWhite(piece) ? 'Q' : 'q';
                const attacker = isWhite(piece) ? 'black' : 'white';
                // King side castle
                if (rights[kingSideKey] && chessBoard[kingRow][5] === '' && chessBoard[kingRow][6] === '' &&
                    !isSquareAttacked(kingRow, 5, attacker, chessBoard) && !isSquareAttacked(kingRow, 6, attacker, chessBoard)) {
                    pseudoLegalMoves.push([kingRow, 6]);
                }
                // Queen side castle
                if (rights[queenSideKey] && chessBoard[kingRow][1] === '' && chessBoard[kingRow][2] === '' && chessBoard[kingRow][3] === '' &&
                    !isSquareAttacked(kingRow, 2, attacker, chessBoard) && !isSquareAttacked(kingRow, 3, attacker, chessBoard)) {
                    pseudoLegalMoves.push([kingRow, 2]);
                }
            }
            return pseudoLegalMoves.filter(([tr, tc]) => {
                const tempBoard = chessBoard.map(r => r.slice());
                // Handle En passant capture in temp board
                if (type === 'P' && enPassantTarget && tr === enPassantTarget[0] && tc === enPassantTarget[1]) {
                    const capturedPawnRow = isWhite(piece) ? tr + 1 : tr - 1;
                    tempBoard[capturedPawnRow][tc] = '';
                }
                tempBoard[tr][tc] = tempBoard[r][c];
                tempBoard[r][c] = '';
                return !isInCheck(turn, tempBoard);
            });
        }

        function movePiece(fr, fc, tr, tc, isPromotionMove = false){
            const piece = chessBoard[fr][fc];
            const capturedPiece = chessBoard[tr][tc];

            // Update Castling Rights for the moving King or Rook
            if (piece === 'K') { castlingRights.w.K = castlingRights.w.Q = false; }
            if (piece === 'k') { castlingRights.b.k = castlingRights.b.q = false; }
            if (piece === 'R' && fr === 7 && fc === 0) { castlingRights.w.Q = false; }
            if (piece === 'R' && fr === 7 && fc === 7) { castlingRights.w.K = false; }
            if (piece === 'r' && fr === 0 && fc === 0) { castlingRights.b.q = false; }
            if (piece === 'r' && fr === 0 && fc === 7) { castlingRights.b.k = false; }

            // Update Castling Rights if a Rook is captured
            if (capturedPiece === 'R' && tr === 7 && tc === 7) { castlingRights.w.K = false; }
            if (capturedPiece === 'R' && tr === 7 && tc === 0) { castlingRights.w.Q = false; }
            if (capturedPiece === 'r' && tr === 0 && tc === 7) { castlingRights.b.k = false; }
            if (capturedPiece === 'r' && tr === 0 && tc === 0) { castlingRights.b.q = false; }

            // Handle En Passant Capture
            const isEnPassant = piece.toUpperCase() === 'P' && enPassantTarget && tr === enPassantTarget[0] && tc === enPassantTarget[1];
            if (isEnPassant) {
                const capturedPawnRow = isWhite(piece) ? tr + 1 : tr - 1;
                chessBoard[capturedPawnRow][tc] = '';
                playMoveSound(true); 
            }
            
            enPassantTarget = null;
            // Set new en passant target
            if (piece.toUpperCase() === 'P' && Math.abs(fr - tr) === 2) {
                enPassantTarget = [(fr + tr) / 2, fc];
            }
            // Handle Castling
            if (piece.toUpperCase() === 'K' && Math.abs(fc - tc) === 2) {
                const r = isWhite(piece) ? 7 : 0;
                if (tc === 6) { 
                    chessBoard[r][5] = chessBoard[r][7];
                    chessBoard[r][7] = '';
                } else { 
                    chessBoard[r][3] = chessBoard[r][0];
                    chessBoard[r][0] = '';
                }
            }
            
            chessBoard[tr][tc] = piece;
            chessBoard[fr][fc] = '';
            
            // Play sound for normal moves and captures, but not en passant which has its own logic above
            if (!isEnPassant) {
                playMoveSound(capturedPiece !== '');
            }
            
            if (!isPromotionMove) {
                turn = (turn === 'white')?'black':'white';
            }
            
            drawBoard();
            checkGameOver();
        }

        function findKing(color, board = chessBoard){
            const k = color === 'white' ? 'K' : 'k';
            for(let i=0; i<8; i++) for(let j=0; j<8; j++) if(board[i][j] === k) return [i, j];
            return null;
        }

        function isInCheck(color, board){
            const kingPos = findKing(color, board);
            if (!kingPos) return false;
            const attackerColor = color === 'white' ? 'black' : 'white';
            return isSquareAttacked(kingPos[0], kingPos[1], attackerColor, board);
        }

        function isSquareAttacked(r, c, attackerColor, board) {
            // Check for pawn attacks
            const pawnDir = attackerColor === 'white' ? -1 : 1;
            const pawnPiece = attackerColor === 'white' ? 'P' : 'p';
            if (inBounds(r + pawnDir, c - 1) && board[r + pawnDir][c - 1] === pawnPiece) return true;
            if (inBounds(r + pawnDir, c + 1) && board[r + pawnDir][c + 1] === pawnPiece) return true;

            // Check for knight attacks
            const knightMoves = [[-2, -1], [-1, -2], [1, -2], [2, -1], [2, 1], [1, 2], [-1, 2], [-2, 1]];
            const knightPiece = attackerColor === 'white' ? 'N' : 'n';
            for (const [dr, dc] of knightMoves) {
                const nr = r + dr;
                const nc = c + dc;
                if (inBounds(nr, nc) && board[nr][nc] === knightPiece) return true;
            }

            // Check for king attacks
            const kingMoves = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];
            const kingPiece = attackerColor === 'white' ? 'K' : 'k';
            for (const [dr, dc] of kingMoves) {
                const nr = r + dr;
                const nc = c + dc;
                if (inBounds(nr, nc) && board[nr][nc] === kingPiece) return true;
            }

            // Check for sliding pieces (Rook/Queen)
            const rookDirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            const rookPieces = attackerColor === 'white' ? ['R', 'Q'] : ['r', 'q'];
            for (const [dr, dc] of rookDirs) {
                let nr = r + dr;
                let nc = c + dc;
                while (inBounds(nr, nc)) {
                    const piece = board[nr][nc];
                    if (piece) {
                        if (rookPieces.includes(piece)) return true;
                        break; 
                    }
                    nr += dr;
                    nc += dc;
                }
            }

            // Check for sliding pieces (Bishop/Queen)
            const bishopDirs = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
            const bishopPieces = attackerColor === 'white' ? ['B', 'Q'] : ['b', 'q'];
            for (const [dr, dc] of bishopDirs) {
                let nr = r + dr;
                let nc = c + dc;
                while (inBounds(nr, nc)) {
                    const piece = board[nr][nc];
                    if (piece) {
                        if (bishopPieces.includes(piece)) return true;
                        break;
                    }
                    nr += dr;
                    nc += dc;
                }
            }

            return false;
        }

        function checkGameOver() {
            let hasLegalMove = false;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = chessBoard[r][c];
                    if (piece && ((turn === 'white' && isWhite(piece)) || (turn === 'black' && !isWhite(piece)))) {
                        if (getLegalMoves(r, c).length > 0) {
                            hasLegalMove = true;
                            break;
                        }
                    }
                }
                if (hasLegalMove) break;
            }
            if (!hasLegalMove) {
                if (isInCheck(turn, chessBoard)) {
                    playCheckmateSound();
                    const winner = turn === 'white' ? 'Black' : 'White';
                    victoryMessageEl.textContent = `Checkmate! ${winner} wins!`;
                    victoryScreenEl.style.display = 'flex';
                    statusEl.textContent = 'Game Over';
                } else {
                    statusEl.textContent = "Stalemate! It's a draw.";
                }
            } else if (isInCheck(turn, chessBoard)){
                playCheckSound();
            }
        }

        function updateStatus(){
            let statusText = `Turn: ${turn.charAt(0).toUpperCase() + turn.slice(1)}`;
            if(isInCheck(turn, chessBoard)){
                statusText += ' - Check!';
            }
            statusEl.textContent = statusText;
        }

        function playMoveSound(isCapture) {
            if (isCapture) {
                captureSound.play();
            } else {
                moveSound.playbackRate = 2; // Set playback speed to 2x for regular moves
                moveSound.play();
            }
        }

        function playCheckSound() {
            checkSound.play();
        }

        function playCheckmateSound() {
            checkmateSound.play();
        }

        function saveState(){
            const state = {
                board: chessBoard.map(r => r.slice()),
                turn: turn,
                castlingRights: JSON.parse(JSON.stringify(castlingRights)),
                enPassantTarget: enPassantTarget
            };
            moveHistory.push(state);
            redoHistory = []; 
        }

        undoBtn.onclick = () => {
            if(moveHistory.length > 0){
                const currentState = {
                    board: chessBoard.map(r => r.slice()),
                    turn: turn,
                    castlingRights: JSON.parse(JSON.stringify(castlingRights)),
                    enPassantTarget: enPassantTarget
                };
                redoHistory.push(currentState);
                const lastState = moveHistory.pop();
                chessBoard = lastState.board.map(r => r.slice());
                turn = lastState.turn;
                castlingRights = lastState.castlingRights;
                enPassantTarget = lastState.enPassantTarget;
                drawBoard();
            }
        };

        redoBtn.onclick = () => {
            if(redoHistory.length > 0){
                const currentState = {
                    board: chessBoard.map(r => r.slice()),
                    turn: turn,
                    castlingRights: JSON.parse(JSON.stringify(castlingRights)),
                    enPassantTarget: enPassantTarget
                };
                moveHistory.push(currentState);
                const nextState = redoHistory.pop();
                chessBoard = nextState.board.map(r => r.slice());
                turn = nextState.turn;
                castlingRights = nextState.castlingRights;
                enPassantTarget = nextState.enPassantTarget;
                drawBoard();
            }
        };
    </script>
</body>
</html>